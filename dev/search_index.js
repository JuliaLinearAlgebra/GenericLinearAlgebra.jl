var documenterSearchIndex = {"docs":
[{"location":"#GenericLinearAlgebra.jl","page":"GenericLinearAlgebra.jl","title":"GenericLinearAlgebra.jl","text":"Documentation for GenericLinearAlgebra.jl","category":"section"},{"location":"#LinearAlgebra.ldlt","page":"GenericLinearAlgebra.jl","title":"LinearAlgebra.ldlt","text":"ldlt(A::Hermitian, blocksize::Int)::LTLt\n\nA Hermitian LDL factorization of A such that A = L*D*L' if A.uplo == 'L' and A = U'*D*U if A.uplo == 'U'. Hence, thet` is a bit of a misnomer, but the name was introduced for real symmetric matrices where there is no difference between the two.\n\nOnly the elements specified by uplo in the Hermitian input will be referenced.\n\nThe factorization has three properties: d, D, and L which is respectively a vector of the diagonal elements of D, the Diagonal matrix D and the L matrix when A.uplo == 'L' or the adjoint of the U matrix when A.uplo == 'U'.\n\nThe blocksize argument controls the block size in the blocked algorithm. Currently, the blocking size is set to 128 ÷ sizeof(eltype(A)) based on very rudimentary benchmarking on my laptop. Most users won't need adjust this argument.\n\nExamples\n\njulia> ldlt(Hermitian([1//1 1; 1 -1]))\nLDLt{Rational{Int64}, Hermitian{Rational{Int64}, Matrix{Rational{Int64}}}}\nL factor:\n2×2 UnitLowerTriangular{Rational{Int64}, Adjoint{Rational{Int64}, Matrix{Rational{Int64}}}}:\n 1  ⋅\n 1  1\nD factor:\n2×2 Diagonal{Rational{Int64}, SubArray{Rational{Int64}, 1, Base.ReshapedArray{Rational{Int64}, 1, Hermitian{Rational{Int64}, Matrix{Rational{Int64}}}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Tuple{StepRange{Int64, Int64}}, false}}:\n 1   ⋅\n ⋅  -2\n\njulia> ldlt(Hermitian([1//1 1; 1 1], :L))\nLDLt{Rational{Int64}, Hermitian{Rational{Int64}, Matrix{Rational{Int64}}}}\nL factor:\n2×2 UnitLowerTriangular{Rational{Int64}, Matrix{Rational{Int64}}}:\n 1  ⋅\n 1  1\nD factor:\n2×2 Diagonal{Rational{Int64}, SubArray{Rational{Int64}, 1, Base.ReshapedArray{Rational{Int64}, 1, Hermitian{Rational{Int64}, Matrix{Rational{Int64}}}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Tuple{StepRange{Int64, Int64}}, false}}:\n 1  ⋅\n ⋅  0\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.ldlt!","page":"GenericLinearAlgebra.jl","title":"LinearAlgebra.ldlt!","text":"ldlt!(A::Hermitian)::LTLt\n\nSee ldlt\n\n\n\n\n\n","category":"function"},{"location":"#GenericLinearAlgebra.numnegevals","page":"GenericLinearAlgebra.jl","title":"GenericLinearAlgebra.numnegevals","text":"Computes the number of negative eigenvalues of T - σI, a.k.a. spectrum slicing\n\nInputs:     T: A SymTridiagonal{<:Real} matrix     σ: The shift parameter\n\nOutputs:     ν: The number of negative eigenvalues\n\nReference:     B. N. Parlett, \"The symmetric eigenvalue problem\", Section 3.3.1, p. 52.\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.svd!","page":"GenericLinearAlgebra.jl","title":"LinearAlgebra.svd!","text":"svd!(A[, tol, full])::SVD\n\nA generic singular value decomposition (SVD). The implementation only uses Julia functions so the SVD can be computed for any element type provided that the necessary arithmetic operations are supported by the element type.\n\ntol: The relative tolerance for determining convergence. The default value is eltype(T) where T is the element type of the input matrix bidiagonal (i.e. after converting the matrix to bidiagonal form).\nfull: If set to true then all the left and right singular vectors are returned. If set to false then only the vectors corresponding to the number of rows and columns of the input matrix A are returned (the default).\n\nAlgorithm\n\n...tomorrow\n\nExample\n\njulia> svd(big.([1 2; 3 4]))\nSVD{BigFloat, BigFloat, Matrix{BigFloat}, Vector{BigFloat}}\nU factor:\n2×2 Matrix{BigFloat}:\n -0.404554   0.914514\n -0.914514  -0.404554\nsingular values:\n2-element Vector{BigFloat}:\n 5.464985704219042650451188493284182533042584640492784181017488774646871847029449\n 0.3659661906262578204229643842614005434788136943931877734325179702209382149672422\nVt factor:\n2×2 Matrix{BigFloat}:\n -0.576048  -0.817416\n -0.817416   0.576048\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.svdvals!","page":"GenericLinearAlgebra.jl","title":"LinearAlgebra.svdvals!","text":"svdvals!(A [, tol])\n\nGeneric computation of singular values.\n\nExamples\n\njulia> using LinearAlgebra, GenericLinearAlgebra, Quaternions\n\njulia> n = 20;\n\njulia> H = [big(1)/(i + j - 1) for i in 1:n, j in 1:n]; # The Hilbert matrix\n\njulia> round(svdvals(H)[end]/svdvals(Float64.(H))[end] - 1, sigdigits=8) # The relative error of the LAPACK based solution rounded to eight significant digits.\n-1.0\n\njulia> A = qr([Quaternion(randn(4)...) for i in 1:3, j in 1:3]).Q *\n           Diagonal([3, 2, 1]) *\n           qr([Quaternion(randn(4)...) for i in 1:3, j in 1:3]).Q';\n\njulia> svdvals(A) ≈ [3, 2, 1]\ntrue\n\n\n\n\n\n","category":"function"}]
}
